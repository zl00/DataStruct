# 基本概念
1. **稳定**：相同的key，位置不受排序算法影响则叫稳定，否则叫不稳定行。

# 种类
1. 插入
   1. 直接 
      1. OBGJECT: 想象待排数组分作 [order section][disorder section]
      2. 逻辑: 将DISORDER元素不断插入到ORDER部分的过程 
            ⚠️找到“合适”位置前，要把“不是目标”位置元素往后挪一位
      3. 复杂度
        时间复杂度：o(n²)
        空间复杂度：o(1)
   2. 折半
      1. 逻辑：在直接插入排序基础上，在“找位置”这步用二分法做了优化。
      2. 复杂度
        时间复杂度：最好o(nlogn), 最差o(n²)
        空间复杂度：o(1)
   3. 希尔(缩小增量排序) __不用写算法，关注执行流程__
      1. 能手写计算流程
      2. 缩小增量规则：
         1. shell：[n/2], [n/4] ... [1] 时间复杂度：o(n²)
         2. Papernove：[2ᵏ+1], ..., [65], [33], ..., [5], [3], [1] (2ᵏ+1 < n) 时间复杂度：o(n^1.5)
      3. 复杂度：
        时间复杂度见上面
        空间复杂度：o(1)
      4. ⚠️
         1. 增量序列最后一项一定是1

2. 交换
   1. 起泡
      1. 逻辑：遍历待排序数组，通过两两比较交换，将最大数字交换到最上面。（如同起泡般）。
            ⚠️起泡可以提前退出，退出是条件是：一轮遍历，发现没有产生一次交换（原理 a<b, b<c, ..., y<z 大小的传递性，所以说明数组是排序好的）
      2. 复杂度：
        时间复杂度：时间复杂度：o(n²)
        空间复杂度：o(1)
   2. 快速
      1. 逻辑：图解见“2_SwapSort_Quick_Logic”，想像成 -- “拍手”，左手遇到比枢纽大的值会停在那里，右手遇到比枢纽小的值也会停在那里，然后2个地方的值交换。这样保证左手扫描过的地方满足<枢纽，右手扫描过的地方满足>枢纽。当2只后重合处，就是放置枢纽的地方。
      2. 复杂度：
        空间复杂度：因为递归压栈log₂ᴺ
        时间复杂度：最好Nlog₂ᴺ，最坏N²，平均Nlog₂ᴺ
        
3. 选择
   1. 简单
   2. 堆
4. 归并
   1. 二路归并
5. 外排


# 🆚表格